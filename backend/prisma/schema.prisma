generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(cuid())
  name                     String
  email                    String                    @unique
  password                 String?
  role                     UserRole                  @default(TENANT)
  googleId                 String?                   @unique
  firstName                String?
  lastName                 String?
  pesel                    String?
  passportNumber           String?
  kartaPobytuNumber        String?
  phoneNumber              String?
  citizenship              String?
  dateOfBirth              DateTime?
  street                   String?
  city                     String?
  zipCode                  String?
  country                  String?
  profession               String?
  dowodOsobistyNumber      String?
  address                  String?
  profileImage             String?
  signatureBase64          String?
  identityDocument         String?
  isVerified               Boolean                   @default(false)
  kycStatus                KYCStatus                 @default(PENDING)
  kycSubmittedAt           DateTime?
  kycReviewedAt            DateTime?
  kycRejectionReason       String?
  kycReviewedBy            String?
  gdprConsent              Boolean                   @default(false)
  gdprConsentDate          DateTime?
  phoneVerified            Boolean                   @default(false)
  emailVerified            Boolean                   @default(false)
  isSuspended              Boolean                   @default(false)
  suspensionReason         String?
  suspendedAt              DateTime?
  availability             Boolean                   @default(true)
  autoAvailability         Boolean                   @default(true)
  maxTenants               Int                       @default(5)
  currentTenants           Int                       @default(0)
  lastActiveAt             DateTime                  @default(now())
  requestCount             Int                       @default(0)
  responseTime             Int?
  averageRating            Float?                   @default(5.0)
  totalReviews            Int                       @default(1)
  rank                    UserRank                  @default(NEW_USER)
  rankPoints              Int                       @default(0)
  rankUpdatedAt           DateTime                  @default(now())
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  conversationParticipants ConversationParticipant[] @relation("UserConversations")
  landlordProfile          LandlordProfile?          @relation("LandlordProfile")
  landlordRequestMatches   LandlordRequestMatch[]    @relation("LandlordMatches")
  leases                   Lease[]                   @relation("TenantLeases")
  sentMessages             Message[]                 @relation("SentMessages")
  offers                   Offer[]                   @relation("LandlordOffers")
  tenantOffers             Offer[]                   @relation("TenantOffers")
  payments                 Payment[]                 @relation("UserPayments")
  properties               Property[]                @relation("LandlordProperties")
  rentPayments             RentPayment[]             @relation("TenantRentPayments")
  rentalRequests           RentalRequest[]           @relation("TenantRequests")
  reviewsGiven            Review[]                  @relation("UserReviewsGiven")
  reviewsReceived         Review[]                  @relation("UserReviewsReceived")
  notifications            Notification[]            @relation("UserNotifications")
  supportTickets          SupportTicket[]           @relation("UserSupportTickets")
  ticketMessages          TicketMessage[]           @relation("UserTicketMessages")
  chatSessions            ChatSession[]             @relation("UserChatSessions")

  @@index([role, availability, autoAvailability, currentTenants])
  @@index([email])
  @@index([lastActiveAt])
  @@map("users")
}

model LandlordProfile {
  id                  String   @id @default(cuid())
  preferredLocations  String?
  maxBudget           Float?
  minBudget           Float?
  maxTenants          Int      @default(5)
  currentTenants      Int      @default(0)
  manualAvailability  Boolean  @default(true)
  autoAvailability    Boolean  @default(true)
  propertyTypes       String?
  amenities           String?
  propertyRules       String?
  propertyDescription String?
  propertyImages      String?
  propertyVideos      String?
  autoFillMedia       Boolean  @default(true)
  autoFillRules       Boolean  @default(true)
  autoFillDescription Boolean  @default(true)
  autoResponse        Boolean  @default(false)
  responseTemplate    String?
  averageResponseTime Int?
  acceptanceRate      Float?
  userId              String   @unique
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation("LandlordProfile", fields: [userId], references: [id], onDelete: Cascade)

  @@index([preferredLocations])
  @@index([maxBudget, minBudget])
  @@index([maxTenants, currentTenants])
  @@index([manualAvailability, autoAvailability])
  @@map("landlord_profiles")
}

model Property {
  id                String         @id @default(cuid())
  name              String
  address           String
  city              String
  district          String?
  zipCode           String
  country           String         @default("Poland")
  propertyType      String
  bedrooms          Int?
  bathrooms         Int?
  size              Float?
  floor             Int?
  totalFloors       Int?
  monthlyRent       Float
  depositAmount     Float?
  utilitiesIncluded Boolean        @default(false)
  availableFrom     DateTime?
  availableUntil    DateTime?
  furnished         Boolean        @default(false)
  parking           Boolean        @default(false)
  petsAllowed       Boolean        @default(false)
  smokingAllowed    Boolean        @default(false)
  status            PropertyStatus @default(AVAILABLE)
  availability      Boolean        @default(true)
  maxTenants        Int            @default(1)
  currentTenants    Int            @default(0)
  description       String?
  houseRules        String?
  images            String?
  videos            String?
  latitude          Float?
  longitude         Float?
  landlordId        String
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  conversations     Conversation[] @relation("PropertyConversations")
  offers            Offer[]        @relation("PropertyOffers")
  matches           LandlordRequestMatch[]
  landlord          User           @relation("LandlordProperties", fields: [landlordId], references: [id], onDelete: Cascade)
  units             Unit[]         @relation("PropertyUnits")

  @@index([landlordId, status])
  @@index([city, status])
  @@index([propertyType, status])
  @@index([monthlyRent, status])
  @@map("properties")
}

model RentalRequest {
  id                     Int                    @id @default(autoincrement())
  title                  String
  description            String
  location               String
  moveInDate             DateTime
  budget                 Float
  budgetFrom             Float?
  budgetTo               Float?
  propertyType           String?
  district               String?
  bedrooms               Int?
  bathrooms              Int?
  furnished              Boolean                @default(false)
  status                 RentalRequestStatus    @default(ACTIVE)
  isLocked               Boolean                @default(false)
  additionalRequirements String?
  preferredNeighborhood  String?
  maxCommuteTime         String?
  mustHaveFeatures       String?
  flexibleOnMoveInDate   Boolean                @default(false)
  poolStatus             RequestPoolStatus      @default(ACTIVE)
  matchScore             Float?
  viewCount              Int                    @default(0)
  responseCount          Int                    @default(0)
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  expiresAt              DateTime?
  tenantId               String
  parking                Boolean?               @default(false)
  petsAllowed            Boolean?               @default(false)
  contractSignature      ContractSignature?     @relation("ContractSignature")
  contract               Contract?              @relation("Contract")
  landlordRequestMatches LandlordRequestMatch[] @relation("RequestMatches")
  offers                 Offer[]                @relation("RequestOffer")
  payments               Payment[]              @relation("RequestPayments")
  tenant                 User                   @relation("TenantRequests", fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([location, status, poolStatus])
  @@index([budget, status])
  @@index([createdAt, poolStatus])
  @@index([tenantId, status])
  @@map("rental_requests")
}

model Offer {
  id                      String          @id @default(cuid())
  rentAmount              Float
  depositAmount           Float?
  leaseDuration           Int
  description             String?
  utilitiesIncluded       Boolean         @default(false)
  availableFrom           DateTime
  status                  OfferStatus     @default(PENDING)
  isPaid                  Boolean         @default(false)
  paymentIntentId         String?
  paymentDate             DateTime?
  leaseStartDate          DateTime?
  leaseEndDate            DateTime?
  propertyAddress         String?
  propertyImages          String?
  propertyVideo           String?
  propertyType            String?
  propertySize            String?
  propertyAmenities       String?
  propertyDescription     String?
  rulesText               String?
  rulesPdf                String?
  preferredPaymentGateway PaymentGateway?
  responseTime            Int?
  matchScore              Float?
  createdAt               DateTime        @default(now())
  updatedAt               DateTime        @updatedAt
  rentalRequestId         Int
  tenantId                String
  landlordId              String
  propertyId              String?
  tenant                  User            @relation("TenantOffers", fields: [tenantId], references: [id], onDelete: Cascade)
  landlord                User            @relation("LandlordOffers", fields: [landlordId], references: [id], onDelete: Cascade)
  property                Property?       @relation("PropertyOffers", fields: [propertyId], references: [id])
  rentalRequest           RentalRequest   @relation("RequestOffer", fields: [rentalRequestId], references: [id], onDelete: Cascade)
  payments                Payment[]       @relation("OfferPayments")
  conversations           Conversation[]  @relation("ConversationOffer")

  @@index([landlordId, status])
  @@index([rentalRequestId, status])
  @@index([status, createdAt])
  @@index([propertyId])
  @@map("offers")
}

model Payment {
  id              String         @id @default(cuid())
  amount          Float
  currency        String         @default("PLN")
  status          PaymentStatus  @default(PENDING)
  paymentIntentId String?        @unique
  purpose         PaymentPurpose
  gateway         PaymentGateway
  processingTime  Int?
  retryCount      Int            @default(0)
  errorMessage    String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  paidAt          DateTime?
  userId          String
  rentalRequestId Int?
  offerId         String?
  leaseId         String?
  lease           Lease?         @relation("LeasePayments", fields: [leaseId], references: [id])
  offer           Offer?         @relation("OfferPayments", fields: [offerId], references: [id])
  rentalRequest   RentalRequest? @relation("RequestPayments", fields: [rentalRequestId], references: [id])
  user            User           @relation("UserPayments", fields: [userId], references: [id], onDelete: Cascade)
  rentPayments    RentPayment[]  @relation("PaymentRentPayments")

  @@index([userId, status])
  @@index([status, createdAt])
  @@index([paymentIntentId])
  @@map("payments")
}

model RentPayment {
  id          String        @id @default(cuid())
  amount      Float
  status      PaymentStatus @default(PENDING)
  dueDate     DateTime
  paidDate    DateTime?
  month       Int
  year        Int
  lateFee     Float         @default(0)
  gracePeriod Int           @default(5)
  isOverdue   Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  userId      String
  paymentId   String?
  payment     Payment?      @relation("PaymentRentPayments", fields: [paymentId], references: [id])
  user        User          @relation("TenantRentPayments", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, month, year])
  @@index([status, dueDate])
  @@index([isOverdue, dueDate])
  @@map("rent_payments")
}

model ContractSignature {
  id              String        @id @default(cuid())
  signature       String
  signedAt        DateTime      @default(now())
  rentalRequestId Int           @unique
  rentalRequest   RentalRequest @relation("ContractSignature", fields: [rentalRequestId], references: [id], onDelete: Cascade)

  @@map("contract_signatures")
}

model Contract {
  id              String         @id @default(cuid())
  contractNumber  String         @unique
  status          ContractStatus @default(SIGNED)
  pdfUrl          String?
  signedAt        DateTime?
  generationTime  Int?
  fileSize        Int?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  rentalRequestId Int            @unique
  rentalRequest   RentalRequest  @relation("Contract", fields: [rentalRequestId], references: [id], onDelete: Cascade)

  @@index([status, signedAt])
  @@index([contractNumber])
  @@map("contracts")
}

model RequestPoolAnalytics {
  id                  String   @id @default(cuid())
  totalRequests       Int      @default(0)
  activeRequests      Int      @default(0)
  matchedRequests     Int      @default(0)
  expiredRequests     Int      @default(0)
  averageResponseTime Int?
  averageMatchScore   Float?
  conversionRate      Float?
  location            String
  requestCount        Int      @default(0)
  landlordCount       Int      @default(0)
  date                DateTime @default(now())

  @@index([location, date])
  @@index([date])
  @@map("request_pool_analytics")
}

model LandlordRequestMatch {
  id              String        @id @default(cuid())
  matchScore      Float
  matchReason     String?
  status          String        @default("ACTIVE")
  isViewed        Boolean       @default(false)
  isResponded     Boolean       @default(false)
  landlordId      String
  rentalRequestId Int
  /// Property anchoring: optional specific property this match refers to
  propertyId      String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  landlord        User          @relation("LandlordMatches", fields: [landlordId], references: [id], onDelete: Cascade)
  rentalRequest   RentalRequest @relation("RequestMatches", fields: [rentalRequestId], references: [id], onDelete: Cascade)
  property        Property?     @relation(fields: [propertyId], references: [id])

  // Allow multiple matches per landlord/request by property
  @@unique([landlordId, rentalRequestId, propertyId])
  @@index([landlordId, matchScore])
  @@index([rentalRequestId, matchScore])
  @@index([isViewed, isResponded])
  @@index([propertyId])
  @@map("landlord_request_matches")
}

model Unit {
  id         String         @id @default(cuid())
  unitNumber String
  floor      Int?
  bedrooms   Int
  bathrooms  Int
  area       Float
  rentAmount Float
  status     PropertyStatus @default(AVAILABLE)
  propertyId String
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  lease      Lease?         @relation("UnitLease")
  property   Property       @relation("PropertyUnits", fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([propertyId, status])
  @@map("units")
}

model Lease {
  id                  String               @id @default(cuid())
  startDate           DateTime
  endDate             DateTime
  rentAmount          Float
  depositAmount       Float
  status              LeaseStatus          @default(ACTIVE)
  tenantId            String
  unitId              String               @unique
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  tenant              User                 @relation("TenantLeases", fields: [tenantId], references: [id], onDelete: Cascade)
  unit                Unit                 @relation("UnitLease", fields: [unitId], references: [id], onDelete: Cascade)
  maintenanceRequests MaintenanceRequest[] @relation("LeaseMaintenance")
  payments            Payment[]            @relation("LeasePayments")
  reviews             Review[]             @relation("LeaseReviews")

  @@index([tenantId])
  @@index([status])
  @@index([endDate])
  @@map("leases")
}

model Review {
  id                    String   @id @default(cuid())
  rating                Int
  comment               String
  isAnonymous           Boolean  @default(false)
  reviewerId            String   // Who is giving the review
  targetUserId          String   // Who is being reviewed
  leaseId               String?
  reviewStage           ReviewStage @default(INITIAL)
  isSystemGenerated     Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  lease                 Lease?   @relation("LeaseReviews", fields: [leaseId], references: [id], onDelete: Cascade)
  reviewer              User     @relation("UserReviewsGiven", fields: [reviewerId], references: [id], onDelete: Cascade)
  targetUser            User     @relation("UserReviewsReceived", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([leaseId])
  @@index([rating])
  @@index([reviewStage])
  @@index([reviewerId])
  @@index([targetUserId])
  @@map("reviews")
}

model MaintenanceRequest {
  id          String              @id @default(cuid())
  title       String
  description String
  priority    MaintenancePriority @default(MEDIUM)
  status      MaintenanceStatus   @default(PENDING)
  leaseId     String
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  lease       Lease               @relation("LeaseMaintenance", fields: [leaseId], references: [id], onDelete: Cascade)

  @@index([leaseId, status])
  @@index([priority])
  @@map("maintenance_requests")
}

model Conversation {
  id           String                    @id @default(cuid())
  title        String?
  type         ConversationType          @default(DIRECT)
  propertyId   String?
  offerId      String?
  status       ConversationStatus        @default(PENDING)
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  participants ConversationParticipant[] @relation("ConversationParticipants")
  property     Property?                 @relation("PropertyConversations", fields: [propertyId], references: [id])
  offer        Offer?                    @relation("ConversationOffer", fields: [offerId], references: [id])
  messages     Message[]                 @relation("ConversationMessages")

  @@index([propertyId])
  @@index([type])
  @@index([status])
  @@index([offerId])
  @@index([status, offerId])
  @@map("conversations")
}

model ConversationParticipant {
  id             String          @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(MEMBER)
  joinedAt       DateTime        @default(now())
  leftAt         DateTime?
  conversation   Conversation    @relation("ConversationParticipants", fields: [conversationId], references: [id], onDelete: Cascade)
  user           User            @relation("UserConversations", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@map("conversation_participants")
}

model Message {
  id             String       @id @default(cuid())
  content        String
  messageType    MessageType  @default(TEXT)
  attachmentUrl  String?
  attachmentName String?
  attachmentSize Int?
  attachmentType String?
  isRead         Boolean      @default(false)
  readAt         DateTime?
  conversationId String
  senderId       String
  replyToId      String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  conversation   Conversation @relation("ConversationMessages", fields: [conversationId], references: [id], onDelete: Cascade)
  replyTo        Message?     @relation("MessageReplies", fields: [replyToId], references: [id])
  replies        Message[]    @relation("MessageReplies")
  sender         User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@index([senderId])
  @@index([isRead])
  @@map("messages")
}

model Notification {
  id          String           @id @default(cuid())
  userId      String
  type        NotificationType
  entityId    String
  title       String
  body        String
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())
  user        User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, isRead, createdAt])
  @@map("notifications")
}

model SupportTicket {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("UserSupportTickets", fields: [userId], references: [id], onDelete: Cascade)
  title       String
  description String
  category    SupportTicketCategory
  priority    SupportTicketPriority
  status      SupportTicketStatus @default(OPEN)
  assignedTo  String?  // Support agent ID
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  messages    TicketMessage[]

  @@index([userId, status])
  @@index([category, priority])
  @@map("support_tickets")
}

model TicketMessage {
  id         String   @id @default(cuid())
  ticketId   String
  ticket     SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  userId     String   // User who sent the message
  user       User     @relation("UserTicketMessages", fields: [userId], references: [id], onDelete: Cascade)
  message    String
  isInternal Boolean  @default(false) // For support team internal notes
  createdAt  DateTime @default(now())

  @@index([ticketId, createdAt])
  @@map("ticket_messages")
}

model ChatSession {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("UserChatSessions", fields: [userId], references: [id], onDelete: Cascade)
  agentId   String?  // Support agent assigned
  status    ChatSessionStatus @default(WAITING)
  startedAt DateTime @default(now())
  endedAt   DateTime?
  messages  ChatMessage[]

  @@index([userId, status])
  @@map("chat_sessions")
}

model ChatMessage {
  id        String   @id @default(cuid())
  sessionId String
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  senderId  String   // User ID or 'support'
  message   String
  timestamp DateTime @default(now())
  isRead    Boolean  @default(false)

  @@index([sessionId, timestamp])
  @@map("chat_messages")
}

enum UserRole {
  TENANT
  LANDLORD
  ADMIN
}

enum RentalRequestStatus {
  ACTIVE
  LOCKED
  MATCHED
  COMPLETED
  CANCELLED
}

enum RequestPoolStatus {
  ACTIVE
  MATCHED
  EXPIRED
  CANCELLED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  REJECTED
  PAID
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum PaymentPurpose {
  DEPOSIT
  RENT
  DEPOSIT_AND_FIRST_MONTH
}

enum ContractStatus {
  SIGNED
  COMPLETED
  EXPIRED
}

enum PaymentGateway {
  STRIPE
  PAYU
  P24
  TPAY
}

enum PropertyStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  RENTED
  UNAVAILABLE
}

enum KYCStatus {
  PENDING
  APPROVED
  REJECTED
  NOT_SUBMITTED
}

enum LeaseStatus {
  ACTIVE
  EXPIRED
  TERMINATED
  PENDING
}

enum MaintenancePriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum MaintenanceStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ReviewStage {
  INITIAL
  PAYMENT_COMPLETED
  MOVE_IN
  LEASE_END
}

enum ConversationType {
  DIRECT
  GROUP
  PROPERTY
}

enum ParticipantRole {
  ADMIN
  MEMBER
  READONLY
}

enum MessageType {
  TEXT
  IMAGE
  DOCUMENT
  SYSTEM
}

enum ConversationStatus {
  PENDING
  ACTIVE
  ARCHIVED
}

enum NotificationType {
  NEW_RENTAL_REQUEST
  NEW_OFFER
  PAYMENT_CONFIRMED
  PAYMENT_FAILED
  CONTRACT_UPDATED
  CONTRACT_SIGNED
  KYC_APPROVED
  KYC_REJECTED
  PROPERTY_STATUS_CHANGED
  SYSTEM_ANNOUNCEMENT
  ACCOUNT_UPDATED
}

enum SupportTicketCategory {
  TECHNICAL
  BILLING
  GENERAL
  EMERGENCY
  PROPERTY_ISSUE
  PAYMENT_ISSUE
}

enum SupportTicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum ChatSessionStatus {
  WAITING
  ACTIVE
  ENDED
}

enum UserRank {
  NEW_USER
  BRONZE_TENANT
  SILVER_TENANT
  GOLD_TENANT
  PLATINUM_TENANT
  BRONZE_LANDLORD
  SILVER_LANDLORD
  GOLD_LANDLORD
  PLATINUM_LANDLORD
  DIAMOND_LANDLORD
}
